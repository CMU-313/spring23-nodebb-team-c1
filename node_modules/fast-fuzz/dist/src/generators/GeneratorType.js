"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorType = void 0;
const class_transformer_1 = require("class-transformer");
const index_1 = require("../intermock/build/index");
const globals_1 = require("../utils/globals");
const limits_1 = require("../utils/limits");
const Generator_1 = require("./Generator");
const Mode_1 = require("./Mode");
class GeneratorType extends Generator_1.Generator {
    constructor(type, dimension = 0, index, mode, isIgnoreFalsy = false) {
        if (GeneratorType.interfaces === undefined) {
            GeneratorType.interfaces = Object.values(globals_1.Globals.codeUtil.interfaces);
        }
        super(dimension, new limits_1.Limits({}), [], index);
        this.falsyLiterals = this.falsyLiterals.concat([{}]);
        this.typeArgs = type.extends;
        this.types = [];
        this.mode = mode === undefined ? Generator_1.Generator.mode : mode;
        this.isIgnoreFalsy = isIgnoreFalsy;
    }
    generate(count) {
        this.init();
        const result = [];
        if (this.mode === Mode_1.Mode.Falsy) {
            const resultFalsy = [];
            for (let index = 0; index < count; index++) {
                resultFalsy.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
            }
            return resultFalsy;
        }
        else if (this.mode === Mode_1.Mode.Stuff && this.typesCount > 0) {
            globals_1.Globals.isLoading = true;
            this.generateStuffInstances(count, false, result);
            globals_1.Globals.isLoading = false;
            this.instanceTypes = result.map(value => value.type);
            return result.map(value => value.instance);
        }
        else {
            if (this.numTypes < 2) {
                this.generateSingle(this.typeArgs[0], this.types[0], count, result);
            }
            else {
                this.generateMany(count, result);
            }
            this.instanceTypes = result.map(value => value.type);
            return result.map(value => value.instance);
        }
    }
    next() {
        const result = Generator_1.Generator.next(this);
        this.nextCount = result.count;
        return result.result;
    }
    nextTypes() {
        if (this.nextCount === 0) {
            return undefined;
        }
        return {
            index: this.index,
            dimension: this.dimension,
            types: this.instanceTypes.splice(-1 * this.nextCount)
        };
    }
    init() {
        if (this.types.length > 0) {
            return;
        }
        this.typeArgs.forEach((typeArg) => {
            this.types.push(Generator_1.Generator.getType(typeArg));
        });
        this.numTypes = this.typeArgs.length;
        this.typesCount = this.generateStuffInstances(0, true);
    }
    generateStuffInstances(count, isDryRun = false, resultsOut = []) {
        const instancesCount = Math.floor(count / this.typesCount);
        let typesCount = 0;
        this.typeArgs.forEach((typeArg, index) => {
            if (globals_1.Globals.instances[typeArg.file] === undefined) {
                return;
            }
            if (globals_1.Globals.instances[typeArg.file][typeArg.name] === undefined) {
                return;
            }
            typesCount++;
            if (isDryRun) {
                return;
            }
            const type = this.types[index];
            globals_1.Globals
                .instances[typeArg.file][typeArg.name]
                .instances
                .forEach(instance => {
                for (let index = 0; index < instancesCount; index++) {
                    if (!this.isIgnoreFalsy && Math.random() > Generator_1.Generator.P_FALSY) {
                        resultsOut.push({
                            instance: this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)],
                            type: typeArg
                        });
                        continue;
                    }
                    resultsOut.push({
                        instance: (0, class_transformer_1.plainToInstance)(type, instance, { enableImplicitConversion: true }),
                        type: typeArg
                    });
                }
            });
        });
        if (!isDryRun && typesCount > 1) {
            GeneratorType.shuffle(resultsOut);
        }
        return typesCount;
    }
    generateSingle(typeArg, type, count, resultsOut) {
        const iResults = (0, index_1.mock)({
            files: GeneratorType.interfaces,
            interfaces: [typeArg.name],
            isOptionalAlwaysEnabled: true,
            output: 'object',
            count
        })[typeArg.name];
        for (let index = 0; index < count; index++) {
            if (!this.isIgnoreFalsy && Math.random() > Generator_1.Generator.P_FALSY) {
                resultsOut.push({
                    type: typeArg,
                    instance: this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]
                });
                continue;
            }
            resultsOut.push({
                type: typeArg,
                instance: (0, class_transformer_1.plainToInstance)(type, iResults[index], { enableImplicitConversion: true })
            });
        }
    }
    generateMany(count, resultsOut) {
        const countPerType = Math.floor(count / this.numTypes);
        for (let index = 0; index < this.numTypes; index++) {
            this.generateSingle(this.typeArgs[index], this.types[index], countPerType, resultsOut);
        }
        GeneratorType.shuffle(resultsOut);
    }
    static shuffle(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] =
                [array[randomIndex], array[currentIndex]];
        }
    }
}
exports.GeneratorType = GeneratorType;
