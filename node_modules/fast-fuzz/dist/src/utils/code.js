"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Code = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const typescript_1 = __importDefault(require("typescript"));
const glob_1 = __importDefault(require("glob"));
const flat_promise_1 = __importDefault(require("flat-promise"));
const tplant_1 = require("tplant");
const modules_1 = require("./modules");
const ComponentKind_1 = require("tplant/dist/Models/ComponentKind");
class Code {
    init(tsFiles, jsFiles) {
        return __awaiter(this, void 0, void 0, function* () {
            this.arg = {
                tsFiles: path_1.default.resolve(tsFiles),
                jsFiles: path_1.default.resolve(jsFiles)
            };
            this.tsFiles = yield Code.getFiles(tsFiles, false);
            this.iFiles = yield Code.getFiles(jsFiles, false);
            this.jsFiles = yield Code.getFiles(jsFiles, true);
            this.typeDefs = tplant_1.tplant.generateDocumentation(this.tsFiles);
            this.methods = {};
            this.typeDefs.forEach((tsFile) => {
                const jsFileMatch = this.getJsFile(tsFile.name);
                if (jsFileMatch === undefined) {
                    return;
                }
                this.methods[jsFileMatch] = [];
                tsFile.parts.forEach((filePart) => {
                    if (filePart.componentKind === ComponentKind_1.ComponentKind.NAMESPACE ||
                        filePart.componentKind === ComponentKind_1.ComponentKind.CLASS ||
                        filePart.componentKind === ComponentKind_1.ComponentKind.METHOD) {
                        Code.getMethods(filePart, this.methods[jsFileMatch], []);
                    }
                });
                Code.getLiterals(tsFile.name, this.methods[jsFileMatch]);
            });
            this.types = {};
            this.typeDefs.forEach((tsFile) => {
                const jsFile = path_1.default.relative(this.arg.tsFiles, tsFile.name).replace('.ts', '.js');
                const jsFileMatch = this.jsFiles.find((jsFilePath) => jsFilePath.endsWith(jsFile));
                if (jsFileMatch === undefined) {
                    return;
                }
                this.types[jsFileMatch] = [];
                tsFile.parts.forEach((filePart) => {
                    if (filePart.componentKind === ComponentKind_1.ComponentKind.NAMESPACE ||
                        filePart.componentKind === ComponentKind_1.ComponentKind.INTERFACE ||
                        filePart.componentKind === ComponentKind_1.ComponentKind.CLASS ||
                        filePart.componentKind === ComponentKind_1.ComponentKind.ENUM) {
                        this.getTypes(jsFileMatch, filePart, this.types[jsFileMatch], []);
                    }
                });
            });
            Object.values(this.types).forEach((moduleTypes) => {
                moduleTypes.forEach((moduleType) => {
                    Code.getExtends(undefined, undefined, moduleType, this.types);
                    moduleType.inherits.forEach((typeTarget) => {
                        Code.getExtends(typeTarget[1], typeTarget[0], moduleType, this.types);
                    });
                });
            });
            this.interfaces = {};
            this.modules = {};
        });
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            for (const iFile of this.iFiles) {
                const jsFile = path_1.default.relative(this.arg.jsFiles, iFile).replace('.d.ts', '.js');
                const jsFileMatch = this.jsFiles.find((jsFilePath) => jsFilePath.endsWith(jsFile));
                if (jsFileMatch === undefined) {
                    continue;
                }
                this.interfaces[jsFileMatch] = Code.getInterfaceFile(iFile);
            }
            for (const jsFile in this.interfaces) {
                const [iFile, iString] = this.interfaces[jsFile];
                const methods = this.methods[jsFile];
                Code.getMethodArguments(iFile, iString, methods);
            }
            this.interfaces['./date.js'] = [
                './date.d.ts',
                `
        export interface Date {
          Date: number;
        }
      `
            ];
            for (const jsFile of this.jsFiles) {
                const tsFile = path_1.default.relative(this.arg.jsFiles, jsFile).replace('.js', '.ts');
                if (this.tsFiles.find((tsFilePath) => tsFilePath.endsWith(tsFile)) === undefined) {
                    continue;
                }
                this.modules[jsFile] = yield (_a = jsFile, Promise.resolve().then(() => __importStar(require(_a))));
            }
        });
    }
    findType(typeName, ICode, file) {
        const startI = ICode[1].indexOf(typeName);
        if (startI === -1) {
            return undefined;
        }
        const endI = ICode[1].indexOf(';', startI) + 1;
        let statement = ICode[1].substring(startI, endI);
        const fromI = statement.indexOf(' from ');
        statement = statement.substring(fromI + 7, statement.length - 2);
        const fileName = path_1.default.resolve(file.replace(path_1.default.basename(file), ''), `${statement}.js`);
        const result = this.types[fileName]
            .find((type) => type.name === typeName);
        return result;
    }
    getJsFile(tsFile) {
        const jsFile = path_1.default.relative(this.arg.tsFiles, tsFile).replace('.ts', '.js');
        const jsFileMatch = this.jsFiles.find((jsFilePath) => jsFilePath.endsWith(jsFile));
        return jsFileMatch;
    }
    static getFiles(filesArgument, isJs) {
        return __awaiter(this, void 0, void 0, function* () {
            const flatPromise = new flat_promise_1.default();
            (0, glob_1.default)(`${filesArgument}/**/*.${isJs ? 'js' : 'ts'}`, {}, (err, matches) => {
                if (err !== null) {
                    flatPromise.reject(err);
                    return;
                }
                const absolutePaths = matches.map((match) => path_1.default.resolve(match));
                flatPromise.resolve(absolutePaths);
            });
            return flatPromise.promise;
        });
    }
    static getLiterals(fileName, moduleMethods) {
        const file = (0, fs_1.readFileSync)(path_1.default.resolve(fileName), 'utf8');
        let currentIndex = -1;
        function findLiterals(node) {
            let isNew = false;
            if (node.kind === typescript_1.default.SyntaxKind.Constructor) {
                isNew = true;
            }
            else if (node.kind === typescript_1.default.SyntaxKind.FunctionDeclaration) {
                const isSkipNested = (currentIndex === moduleMethods.length - 1) ||
                    moduleMethods[currentIndex + 1].name !== node.name.escapedText;
                isNew = !isSkipNested;
            }
            else if (node.kind === typescript_1.default.SyntaxKind.MethodDeclaration) {
                const modifiers = typescript_1.default.canHaveModifiers(node) ? typescript_1.default.getModifiers(node) : undefined;
                const isSkipModifier = modifiers === null || modifiers === void 0 ? void 0 : modifiers.find((modifier) => [
                    typescript_1.default.SyntaxKind.AbstractKeyword,
                    typescript_1.default.SyntaxKind.PrivateKeyword,
                    typescript_1.default.SyntaxKind.ProtectedKeyword
                ].includes(modifier.kind));
                isNew = isSkipModifier === undefined;
            }
            if (isNew) {
                currentIndex++;
            }
            if (currentIndex === -1) {
                typescript_1.default.forEachChild(node, findLiterals);
                return;
            }
            if (node.kind === typescript_1.default.SyntaxKind.NumericLiteral ||
                node.kind === typescript_1.default.SyntaxKind.BigIntLiteral ||
                node.kind === typescript_1.default.SyntaxKind.StringLiteral) {
                let isDecorator = false;
                let parentNode = node;
                while (parentNode.parent !== undefined) {
                    isDecorator = isDecorator || parentNode.kind === typescript_1.default.SyntaxKind.Decorator;
                    parentNode = parentNode.parent;
                }
                if (!isDecorator) {
                    moduleMethods[currentIndex].literals.push(node.getText());
                }
            }
            typescript_1.default.forEachChild(node, findLiterals);
        }
        if (moduleMethods.length > 0) {
            const sourceFile = typescript_1.default.createSourceFile(fileName, file, typescript_1.default.ScriptTarget.ES2015, true);
            findLiterals(sourceFile);
        }
    }
    static getMethods(filePart, methodsOut, namespaces, className) {
        if (filePart.componentKind === ComponentKind_1.ComponentKind.NAMESPACE) {
            filePart.parts.forEach((fileSubPart) => {
                Code.getMethods(fileSubPart, methodsOut, namespaces.concat([filePart.name]));
            });
        }
        else if (filePart.componentKind === ComponentKind_1.ComponentKind.CLASS) {
            filePart.constructorMethods.forEach((fileSubPart) => {
                Code.getMethods(fileSubPart, methodsOut, namespaces, filePart.name);
            });
            filePart.members.forEach((fileSubPart) => {
                Code.getMethods(fileSubPart, methodsOut, namespaces, filePart.name);
            });
        }
        else if (filePart.componentKind === ComponentKind_1.ComponentKind.METHOD) {
            if (filePart.modifier !== 'public' ||
                filePart.isAbstract ||
                className === undefined) {
                return;
            }
            const method = new modules_1.ModuleMethod({
                name: filePart.name,
                className,
                namespaces,
                isAbstract: filePart.isAbstract,
                isAsync: filePart.isAsync,
                isStatic: filePart.isStatic,
                literals: [],
                test: {
                    args: [],
                    isStart: false,
                    generators: [],
                    typeGenerators: []
                },
                args: filePart.parameters.map((arg) => arg.name)
            });
            methodsOut.push(method);
        }
    }
    getTypes(file, filePart, typesOut, namespaces) {
        if (filePart.componentKind === ComponentKind_1.ComponentKind.NAMESPACE) {
            filePart.parts.forEach((fileSubPart) => {
                this.getTypes(file, fileSubPart, typesOut, namespaces.concat([filePart.name]));
            });
        }
        else if (filePart.componentKind === ComponentKind_1.ComponentKind.ENUM) {
            typesOut.push(new modules_1.ModuleType({
                name: filePart.name,
                namespaces: namespaces,
                file: file,
                kind: 'enum',
                inherits: []
            }));
        }
        else if (filePart.componentKind === ComponentKind_1.ComponentKind.INTERFACE) {
            typesOut.push(new modules_1.ModuleType({
                name: filePart.name,
                namespaces: namespaces,
                file: file,
                kind: 'interface',
                inherits: []
            }));
        }
        else if (filePart.componentKind === ComponentKind_1.ComponentKind.CLASS) {
            const result = new modules_1.ModuleType({
                name: filePart.name,
                namespaces: namespaces,
                file: file,
                kind: 'class',
                isAbstract: filePart.isAbstract,
                inherits: []
            });
            if (filePart.extendsClass !== undefined) {
                result.inherits.push([
                    this.getJsFile(path_1.default.resolve(filePart.extendsClassFile)),
                    filePart.extendsClass
                        .substring(Math.max(0, filePart.extendsClass.lastIndexOf('.')))
                        .replace('.', '')
                ]);
            }
            filePart.implementsInterfaces.forEach((iName, index) => {
                result.inherits.push([
                    this.getJsFile(path_1.default.resolve(filePart.implementsInterfacesFiles[index])),
                    iName
                        .substring(Math.max(0, iName.lastIndexOf('.')))
                        .replace('.', '')
                ]);
            });
            typesOut.push(result);
        }
    }
    static getExtends(target, targetFile, newType, types) {
        if (newType.kind !== 'interface' &&
            !newType.isAbstract) {
            if (newType.extends === undefined) {
                newType.extends = [];
            }
            const selfTypeExists = newType.extends.find((extendsType) => extendsType.name === newType.name);
            if (selfTypeExists === undefined) {
                newType.extends.push(newType);
            }
        }
        else {
            return;
        }
        if (target === undefined ||
            targetFile === undefined) {
            return;
        }
        const targetType = types[targetFile].find((targetType) => targetType.name === target);
        if (targetType.inherits !== undefined &&
            targetType.inherits.length > 0) {
            targetType.inherits.forEach((inherit) => {
                Code.getExtends(inherit[1], inherit[0], newType, types);
            });
        }
        if (targetType.extends === undefined) {
            targetType.extends = [];
        }
        const moduleTypeExists = targetType.extends.find((extendsType) => extendsType.name === newType.name);
        if (moduleTypeExists === undefined) {
            targetType.extends.push(newType);
        }
    }
    static getInterfaceFile(iFile) {
        let code = (0, fs_1.readFileSync)(iFile, 'utf8');
        code = code.replace(new RegExp(' abstract ', 'gm'), ' ');
        code = code.replace(new RegExp(' implements ', 'gm'), ' extends ');
        code = code.replace(new RegExp(' class ', 'gm'), ' interface ');
        code = Code.getEnumStatements(code);
        return [iFile, code];
    }
    static getEnumStatements(code) {
        var _a;
        const allEnumsPattern = new RegExp('enum [\\s\\S]*?\\}', 'gm');
        const firstEnumPattern = new RegExp('enum [\\s\\S]*?\\}', 'm');
        const enumValuePattern = new RegExp('\\{[\\s\\S]*\\}', 'gm');
        let result = code;
        (_a = code.match(allEnumsPattern)) === null || _a === void 0 ? void 0 : _a.forEach((enumStatement) => {
            const enumNamePattern = new RegExp('enum (.*?) ', 'gm');
            const name = enumNamePattern.exec(enumStatement)[1];
            const objectCode = enumStatement.replace(new RegExp('=', 'gm'), ':');
            const valueObject = eval(`(${objectCode.match(enumValuePattern)[0]})`);
            let valueDefinition;
            for (const key in valueObject) {
                if (valueDefinition === undefined) {
                    valueDefinition = `${JSON.stringify(valueObject[key])}`;
                    continue;
                }
                valueDefinition += ` | ${JSON.stringify(valueObject[key])}`;
            }
            const enumDefinition = `interface ${name} { ${name}: ${valueDefinition} }`;
            result = result.replace(firstEnumPattern, enumDefinition);
        });
        return result;
    }
    static getMethodArguments(iFile, iString, methods) {
        let indexLastImport = iString.lastIndexOf('import ');
        if (indexLastImport > -1) {
            indexLastImport = iString.indexOf(';', indexLastImport) + 1;
        }
        const importSection = iString.substring(0, Math.max(0, indexLastImport));
        let currentIndex = 0;
        methods === null || methods === void 0 ? void 0 : methods.forEach((method) => {
            let methodName = method.name;
            if (methodName === '__constructor') {
                methodName = 'constructor';
            }
            currentIndex = iString.indexOf(methodName, currentIndex);
            const endSignatureIndex = iString.indexOf(';', currentIndex);
            const methodSignature = iString.substring(currentIndex, endSignatureIndex);
            currentIndex = endSignatureIndex;
            const startArgsIndex = methodSignature.indexOf('(');
            const endArgsIndex = methodSignature.lastIndexOf(')');
            let argsSignature = methodSignature.substring(startArgsIndex, endArgsIndex).slice(1);
            method.args.forEach((arg) => {
                argsSignature = argsSignature.replace(new RegExp(`\\,[\\s]*${arg}`, 'm'), `; ${arg}`);
            });
            const fileName = path_1.default.basename(iFile).replace('.d.ts', '');
            method.IArgs = [
                iFile.replace(fileName, 'IFuzzArgs'),
                `${importSection} declare interface IFuzzArgs { ${argsSignature} }`
            ];
        });
    }
}
exports.Code = Code;
