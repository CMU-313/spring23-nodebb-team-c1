"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fuzzAsync = void 0;
const path_1 = __importDefault(require("path"));
const fast_copy_1 = __importDefault(require("fast-copy"));
const deep_object_diff_1 = require("deep-object-diff");
const util_1 = require("./util");
const Mode_1 = require("../generators/Mode");
const result_1 = require("./result");
const globals_1 = require("../utils/globals");
const Generator_1 = require("../generators/Generator");
const MODE_SCALE = 1.5;
function fuzzAsync(method, getArgs, testFunc, filePath, maxTime = 1e4, maxRuns = 1e5, resultsOut, persistInstances) {
    return __awaiter(this, void 0, void 0, function* () {
        filePath = path_1.default.resolve(filePath);
        if (!global.__coverage__[filePath]) {
            throw new Error(`File not found: ${filePath}`);
        }
        (0, util_1.resetCoverage)(filePath);
        const maxRunsModes = [];
        const maxMode = Mode_1.Mode.High_2;
        let runsDiff = maxRuns;
        for (let index = maxMode + 1; index > 0; index--) {
            const runsPerMode = runsDiff / index;
            const scaleRuns = Math.floor(runsPerMode * MODE_SCALE);
            maxRunsModes.push(scaleRuns);
            runsDiff -= scaleRuns;
        }
        const covResults = new Set();
        let resultCount = 1;
        for (let mode = 0; mode <= maxMode; mode++) {
            Generator_1.Generator.mode = mode;
            globals_1.Globals.mode = mode;
            let runCount = 0;
            let lastIndex = 0;
            const maxRunsMode = maxRunsModes.pop();
            const maxRunsFailFast = Math.floor(0.682 * maxRunsMode);
            const maxRunsCheck = Math.pow(10, Math.max(1, Math.floor(Math.log10(maxRunsMode)) - 1));
            const start = Date.now();
            const runTime = maxTime * maxRunsMode / (MODE_SCALE * maxRuns);
            const fileCoverage = {
                s: global.__coverage__[filePath].s,
                b: global.__coverage__[filePath].b,
                bT: global.__coverage__[filePath].bT
            };
            let isExpired = false;
            while (true) {
                if (runCount % maxRunsCheck == 0) {
                    isExpired = (Date.now() - start) > runTime;
                    isExpired = isExpired || ((runCount - lastIndex) > maxRunsFailFast);
                }
                if (isExpired || runCount > maxRunsMode) {
                    break;
                }
                runCount++;
                const args = getArgs();
                let isError = false;
                let result;
                const covBefore = (0, fast_copy_1.default)(fileCoverage);
                try {
                    result = yield testFunc(args);
                }
                catch (error) {
                    isError = true;
                    result = error;
                }
                let covDiff = JSON.stringify({
                    s: (0, deep_object_diff_1.diff)(covBefore === null || covBefore === void 0 ? void 0 : covBefore.s, fileCoverage.s),
                    b: (0, deep_object_diff_1.diff)(covBefore === null || covBefore === void 0 ? void 0 : covBefore.b, fileCoverage.b),
                    bT: (0, deep_object_diff_1.diff)(covBefore === null || covBefore === void 0 ? void 0 : covBefore.bT, fileCoverage.bT)
                });
                covDiff = covDiff.replace(/:\d+/g, ":1");
                covDiff = covDiff.replace(/:null/g, ":1");
                const coverageHash = (0, util_1.simpleHash)(covDiff);
                if (covResults.has(coverageHash)) {
                    continue;
                }
                covResults.add(coverageHash);
                if (isError) {
                    (0, util_1.cleanupError)(result);
                }
                resultsOut.push(new result_1.Result({
                    id: resultCount++,
                    modeId: mode,
                    mode: Mode_1.Mode[mode],
                    instance: method.test.instance,
                    args: method.test.callArgs,
                    result, coverageHash, runCount,
                    speed: Number.parseFloat((runCount * 1000 / (Date.now() - start)).toPrecision(4))
                }));
                const globalStatements = global.__coverage__[filePath].s;
                for (const statementName in globalStatements) {
                    globalStatements[statementName] = 0;
                }
                lastIndex = runCount;
                persistInstances();
            }
        }
        return resultsOut;
    });
}
exports.fuzzAsync = fuzzAsync;
