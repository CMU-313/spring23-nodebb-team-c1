"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorString = void 0;
const limits_1 = require("../utils/limits");
const Generator_1 = require("./Generator");
const Mode_1 = require("./Mode");
class GeneratorString extends Generator_1.Generator {
    constructor(dimension = 0, literals, min, max, index) {
        super(dimension, new limits_1.Limits({ string: { min, max } }), Generator_1.Generator.getLiterals('string', literals), index);
        this.falsyLiterals = this.falsyLiterals.concat([
            '', 'RkeRxOSF4BfSpgc5Dc7hGumMO'
        ]);
    }
    generate(count) {
        const result = [];
        if (Generator_1.Generator.mode === Mode_1.Mode.Falsy) {
            for (let index = 0; index < count; index++) {
                result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
            }
        }
        else if (Generator_1.Generator.mode === Mode_1.Mode.Stuff && this.literals.length > 0) {
            for (let index = 0; index < count; index++) {
                if (Math.random() > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
            }
        }
        else {
            const [min, max] = GeneratorString.getLimits(Generator_1.Generator.mode, this.limits.string.min, this.limits.string.max);
            for (let index = 0; index < count; index++) {
                const random = Math.random();
                if (random > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                else if (random > 0.2 && this.literals.length > 0) {
                    result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
                    continue;
                }
                result.push(`${Math.random().toString(36)}00000000000000000`
                    .slice(2, Generator_1.Generator.getRandomInt(min, max) + 2));
            }
        }
        return result;
    }
    next() {
        return Generator_1.Generator.next(this).result;
    }
    static getLimits(mode, min, max) {
        switch (mode) {
            case Mode_1.Mode.Falsy:
            case Mode_1.Mode.Stuff:
            case Mode_1.Mode.Low_1:
            case Mode_1.Mode.Low_2:
                return [
                    Math.max(1, min + GeneratorString.MODE_SCALE),
                    Math.max(2, max - GeneratorString.MODE_SCALE),
                ];
            case Mode_1.Mode.Medium:
                return [min, max];
            case Mode_1.Mode.High_1:
                return [
                    Math.max(1, min - GeneratorString.MODE_SCALE),
                    Math.max(2, max + GeneratorString.MODE_SCALE)
                ];
            case Mode_1.Mode.High_2:
                return [
                    Math.max(1, min - GeneratorString.MODE_SCALE * 2),
                    Math.max(2, max + GeneratorString.MODE_SCALE * 2)
                ];
        }
    }
}
exports.GeneratorString = GeneratorString;
GeneratorString.MODE_SCALE = 1;
