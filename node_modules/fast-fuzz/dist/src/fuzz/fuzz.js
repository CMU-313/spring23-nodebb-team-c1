"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInstances = exports.fuzz = exports.count = exports.init = void 0;
const istanbul_lib_instrument_1 = require("istanbul-lib-instrument");
const istanbul_lib_hook_1 = require("istanbul-lib-hook");
const path_1 = __importDefault(require("path"));
const globals_1 = require("../utils/globals");
const code_1 = require("../utils/code");
const fuzzAsync_1 = require("./fuzzAsync");
const fuzzSync_1 = require("./fuzzSync");
const GeneratorArg_1 = require("../generators/GeneratorArg");
const GeneratorFactory_1 = require("../generators/GeneratorFactory");
const Mode_1 = require("../generators/Mode");
let instrumenter;
(0, istanbul_lib_hook_1.hookRequire)((_filePath) => true, (code, { filename }) => {
    if (filename.includes('node_modules')) {
        return code;
    }
    const newCode = instrumenter.instrumentSync(code, filename);
    return newCode;
});
let currentFolder;
let interfaces;
let instances = [];
function init(folder, src, dist, instances) {
    return __awaiter(this, void 0, void 0, function* () {
        if (instances !== undefined) {
            globals_1.Globals.instances = instances;
        }
        yield initLocal(folder, src, dist);
    });
}
exports.init = init;
function initLocal(folder, src = 'src/', dist = 'dist/') {
    return __awaiter(this, void 0, void 0, function* () {
        if (currentFolder !== undefined &&
            currentFolder === folder) {
            return;
        }
        globals_1.Globals.isTest = true;
        globals_1.Globals.codeUtil = new code_1.Code();
        yield globals_1.Globals.codeUtil.init(path_1.default
            .join(folder, src)
            .replace(new RegExp('\\\\', 'g'), '/')
            .replace(new RegExp('\\\\\\\\', 'g'), '/'), path_1.default
            .join(folder, dist)
            .replace(new RegExp('\\\\', 'g'), '/')
            .replace(new RegExp('\\\\\\\\', 'g'), '/'));
        instrumenter = (0, istanbul_lib_instrument_1.createInstrumenter)({ compact: true, reportLogic: true });
        yield globals_1.Globals.codeUtil.load();
        currentFolder = folder;
    });
}
function checkInit() {
    if (instrumenter === undefined) {
        throw new Error('The Fuzz method only runs after calling init. ');
    }
}
function count(methodPattern, classPattern, filePattern) {
    return __awaiter(this, void 0, void 0, function* () {
        checkInit();
        let methodCount = 0;
        for (const [file, methods] of Object.entries(globals_1.Globals.codeUtil.methods)) {
            if (filePattern !== undefined && !(new RegExp(filePattern)).test(file)) {
                continue;
            }
            for (const method of methods) {
                if (classPattern !== undefined && !(new RegExp(classPattern)).test(method.className)) {
                    continue;
                }
                if (methodPattern !== undefined && !(new RegExp(methodPattern)).test(method.name)) {
                    continue;
                }
                if (method.name === '__constructor') {
                    continue;
                }
                methodCount++;
            }
        }
        return methodCount;
    });
}
exports.count = count;
function fuzz(maxTime = 1e4, methodPattern, classPattern, filePattern, resultsOut = [], index = 0, count = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        let currentCount = 0;
        let currentIndex = 0;
        checkInit();
        interfaces = Object.values(globals_1.Globals.codeUtil.interfaces);
        for (const [file, methods] of Object.entries(globals_1.Globals.codeUtil.methods)) {
            if (filePattern !== undefined && !(new RegExp(filePattern)).test(file)) {
                continue;
            }
            for (const method of methods) {
                if (classPattern !== undefined && !(new RegExp(classPattern)).test(method.className)) {
                    continue;
                }
                if (methodPattern !== undefined && !(new RegExp(methodPattern)).test(method.name)) {
                    continue;
                }
                if (method.name === '__constructor') {
                    continue;
                }
                if (count !== 0 && currentCount >= count) {
                    break;
                }
                if (currentIndex < index) {
                    currentIndex++;
                    continue;
                }
                currentIndex++;
                currentCount++;
                globals_1.Globals.literals = method.literals;
                const maxRuns = yield getMaxRuns(method, file, maxTime);
                const fuzzResults = yield fuzzAnyMethod(method, file, maxTime, maxRuns);
                resultsOut.push({
                    name: method.name,
                    className: method.className,
                    namespaces: method.namespaces,
                    file,
                    avgSpeed: maxRuns / maxTime,
                    results: fuzzResults
                });
                loadInstances(instances, globals_1.Globals.instances);
                instances = [];
            }
        }
        return resultsOut;
    });
}
exports.fuzz = fuzz;
function getMaxRuns(method, file, maxTime) {
    return __awaiter(this, void 0, void 0, function* () {
        const numRuns = 1e3;
        const start = Date.now();
        yield fuzzAnyMethod(method, file, maxTime / 10, numRuns);
        const result = Math.floor(maxTime / ((Date.now() - start) / numRuns));
        return Math.max(numRuns, result);
    });
}
function fuzzAnyMethod(method, file, maxTime, maxRuns) {
    return __awaiter(this, void 0, void 0, function* () {
        globals_1.Globals.methodCount++;
        let fuzzResults = [];
        if (method.isStatic || method.className === undefined) {
            if (method.isAsync) {
                fuzzResults = yield fuzzStaticAsync(file, method, maxTime, maxRuns, fuzzResults);
            }
            else {
                fuzzResults = fuzzStatic(file, method, maxTime, maxRuns, fuzzResults);
            }
        }
        else {
            if (method.isAsync) {
                fuzzResults = yield fuzzMethodAsync(file, method, maxTime, maxRuns, fuzzResults);
            }
            else {
                fuzzResults = fuzzMethod(file, method, maxTime, maxRuns, fuzzResults);
            }
        }
        return fuzzResults;
    });
}
function fuzzStatic(filePath, method, maxTime = 1e4, maxRuns = 1e5, resultsOut) {
    interfaces.push(method.IArgs);
    const argGenerator = new GeneratorArg_1.GeneratorArg(interfaces);
    const type = globals_1.Globals
        .codeUtil
        .types[filePath]
        .find((moduleType) => moduleType.name === method.className);
    let func = globals_1.Globals.codeUtil.modules[filePath];
    type.namespaces.forEach((namespace) => {
        func = func[namespace];
    });
    if (method.className !== undefined) {
        func = func[method.className];
    }
    func = func[method.name];
    const results = (0, fuzzSync_1.fuzzSync)(method, () => getArgs(method, argGenerator), (args) => func(...args), filePath, maxTime, maxRuns, resultsOut, () => {
        if (globals_1.Globals.mode <= Mode_1.Mode.Stuff) {
            return;
        }
        instances.push({
            args: method.test.callArgs,
            callTypes: method.test.callArgsTypes
        });
    });
    interfaces.pop();
    return results;
}
function fuzzStaticAsync(filePath, method, maxTime = 1e4, maxRuns = 1e5, resultsOut) {
    return __awaiter(this, void 0, void 0, function* () {
        interfaces.push(method.IArgs);
        const argGenerator = new GeneratorArg_1.GeneratorArg(interfaces);
        const type = globals_1.Globals
            .codeUtil
            .types[filePath]
            .find((moduleType) => moduleType.name === method.className);
        let func = globals_1.Globals.codeUtil.modules[filePath];
        type.namespaces.forEach((namespace) => {
            func = func[namespace];
        });
        if (method.className !== undefined) {
            func = func[method.className];
        }
        func = func[method.name];
        const results = yield (0, fuzzAsync_1.fuzzAsync)(method, () => getArgs(method, argGenerator), (args) => __awaiter(this, void 0, void 0, function* () { return yield func(...args); }), filePath, maxTime, maxRuns, resultsOut, () => {
            if (globals_1.Globals.mode <= Mode_1.Mode.Stuff) {
                return;
            }
            instances.push({
                args: method.test.callArgs,
                callTypes: method.test.callArgsTypes
            });
        });
        interfaces.pop();
        return results;
    });
}
function fuzzMethod(filePath, method, maxTime = 1e4, maxRuns = 1e5, resultsOut) {
    interfaces.push(method.IArgs);
    const argGenerator = new GeneratorArg_1.GeneratorArg(interfaces);
    const type = globals_1.Globals
        .codeUtil
        .types[filePath]
        .find((moduleType) => moduleType.name === method.className);
    method.test.instanceType = type;
    let isIncrement = false;
    let generator = GeneratorFactory_1.GeneratorFactory.initType(type, 0, 0, Mode_1.Mode.Stuff, true);
    const results = (0, fuzzSync_1.fuzzSync)(method, () => {
        if (!isIncrement && globals_1.Globals.mode > Mode_1.Mode.Stuff) {
            isIncrement = true;
            generator = GeneratorFactory_1.GeneratorFactory.initType(type, 0, 0, Mode_1.Mode.Low_2, true);
        }
        method.test.instance = generator.next();
        return getArgs(method, argGenerator);
    }, (args) => {
        return method.test.instance[method.name](...args);
    }, filePath, maxTime, maxRuns, resultsOut, () => {
        if (globals_1.Globals.mode <= Mode_1.Mode.Stuff) {
            return;
        }
        instances.push({
            args: method.test.callArgs,
            callTypes: method.test.callArgsTypes
        });
        instances.push({
            args: [method.test.instance],
            callTypes: [{
                    index: 0,
                    dimension: 0,
                    types: [type]
                }]
        });
    });
    interfaces.pop();
    return results;
}
function fuzzMethodAsync(filePath, method, maxTime = 1e4, maxRuns = 1e5, resultsOut) {
    return __awaiter(this, void 0, void 0, function* () {
        interfaces.push(method.IArgs);
        const argGenerator = new GeneratorArg_1.GeneratorArg(interfaces);
        const type = globals_1.Globals
            .codeUtil
            .types[filePath]
            .find((moduleType) => moduleType.name === method.className);
        method.test.instanceType = type;
        let isIncrement = false;
        let generator = GeneratorFactory_1.GeneratorFactory.initType(type, 0, 0, Mode_1.Mode.Stuff, true);
        const results = yield (0, fuzzAsync_1.fuzzAsync)(method, () => {
            if (!isIncrement && globals_1.Globals.mode > Mode_1.Mode.Stuff) {
                isIncrement = true;
                generator = GeneratorFactory_1.GeneratorFactory.initType(type, 0, 0, Mode_1.Mode.Low_2, true);
            }
            method.test.instance = generator.next();
            return getArgs(method, argGenerator);
        }, (args) => __awaiter(this, void 0, void 0, function* () {
            return yield method.test.instance[method.name](...args);
        }), filePath, maxTime, maxRuns, resultsOut, () => {
            if (globals_1.Globals.mode <= Mode_1.Mode.Stuff) {
                return;
            }
            instances.push({
                args: method.test.callArgs,
                callTypes: method.test.callArgsTypes
            });
            instances.push({
                args: [method.test.instance],
                callTypes: [{
                        index: 0,
                        dimension: 0,
                        types: [type]
                    }]
            });
        });
        interfaces.pop();
        return results;
    });
}
function getArgs(method, generator) {
    method.test.isStart = true;
    method.test.callArgsTypes = [];
    const resultObject = generator.next();
    const result = [];
    method.args.forEach((arg) => {
        result.push(resultObject[arg]);
    });
    method.test.callArgs = result;
    return result;
}
function loadInstances(instances, instancesOut) {
    instances.forEach(instance => {
        if (instance === undefined ||
            instance.args === undefined ||
            instance.args.length === 0) {
            return;
        }
        instance.callTypes.forEach(callType => {
            let arg = instance.args[callType.index];
            if (arg === undefined ||
                callType.types === undefined ||
                callType.types.length === 0) {
                return;
            }
            if (callType.dimension === 0) {
                arg = [arg];
            }
            else {
                arg = arg.flat();
            }
            for (let index = 0; index < arg.length; index++) {
                const argElement = arg[index];
                const typeElement = callType.types[index];
                if (instancesOut[typeElement.file] === undefined) {
                    instancesOut[typeElement.file] = {};
                }
                if (instancesOut[typeElement.file][typeElement.name] === undefined) {
                    instancesOut[typeElement.file][typeElement.name] = {
                        instances: []
                    };
                }
                instancesOut[typeElement.file][typeElement.name]
                    .instances
                    .push(argElement);
            }
        });
    });
}
function getInstances() {
    return __awaiter(this, void 0, void 0, function* () {
        return globals_1.Globals.instances;
    });
}
exports.getInstances = getInstances;
