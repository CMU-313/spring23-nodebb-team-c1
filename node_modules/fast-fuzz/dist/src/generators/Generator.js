"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generator = void 0;
const make_matrix_1 = __importDefault(require("make-matrix"));
const globals_1 = require("../utils/globals");
const Mode_1 = require("./Mode");
class Generator {
    constructor(dimension = 0, limits, literals, index) {
        this.dimension = Math.max(dimension, 0);
        this.limits = limits;
        this.literals = literals;
        this.falsyLiterals = [undefined, null];
        this.index = index;
        Generator.reset(this);
    }
    static getLiterals(type, literals) {
        const byType = { integer: [], float: [], date: [], string: [], boolean: [] };
        literals.forEach((literal) => {
            const num = Number.parseFloat(literal);
            const int = Number.parseInt(literal);
            if (literal === '' ||
                literal === '""' ||
                literal === "''" ||
                literal === 'null' ||
                literal === 'undefined' ||
                literal === 'false' ||
                literal === 'true' ||
                literal === 'NaN') {
                return;
            }
            else if (num === 0 ||
                num === Number.MIN_VALUE,
                num === -1 * Number.MIN_VALUE) {
                return;
            }
            if (!Number.isNaN(num)) {
                if (!Number.isNaN(int)) {
                    byType.integer.push(int);
                    return;
                }
                byType.float.push(num);
            }
            else if (!Number.isNaN(Date.parse(literal))) {
                byType.date.push(new Date(Date.parse(literal)));
            }
            else {
                byType.string.push(literal.substring(1, literal.length - 1));
            }
        });
        let result = byType[type];
        if (type === 'float') {
            result = result.concat(byType.integer);
        }
        return result;
    }
    static generate(generator, count) {
        if (Math.max(count, generator.count) / generator.batchSize > 10) {
            Generator.reset(generator);
            generator.batchSize = Math.max(count, generator.batchSize * 2);
        }
        const newBatch = generator.generate(Math.max(count, generator.batchSize));
        generator.values = newBatch;
        generator.count += newBatch.length;
    }
    static next(generator) {
        if (generator.dimension === 0) {
            if (generator.values.length === 0) {
                Generator.generate(generator, 1);
            }
            return {
                count: 1,
                result: generator.values.pop()
            };
        }
        else if (generator.dimension === 1) {
            if (Math.random() > Generator.P_FALSY) {
                return {
                    count: 0,
                    result: Generator.DEFAULT_FALSY[Generator.getRandomIndex(Generator.DEFAULT_FALSY.length)]
                };
            }
            const limit = generator.limits.array;
            const count = Generator.getRandomInt(limit.min, limit.max);
            if (count > generator.values.length) {
                Generator.generate(generator, count);
            }
            const result = [];
            for (let index = 0; index < count; index++) {
                result.push(generator.values.pop());
            }
            return { count, result };
        }
        else {
            if (Math.random() > Generator.P_FALSY) {
                return {
                    count: 0,
                    result: Generator.DEFAULT_FALSY[Generator.getRandomIndex(Generator.DEFAULT_FALSY.length)]
                };
            }
            const dLimit = generator.limits.array;
            const dSizes = [];
            let totalSize = 1;
            for (let index = 0; index < generator.dimension; index++) {
                const dSize = Generator.getRandomInt(dLimit.min + 1, dLimit.max);
                dSizes.push(dSize);
                totalSize *= dSize;
            }
            if (totalSize > generator.values.length) {
                Generator.generate(generator, totalSize);
            }
            let count = 0;
            const result = (0, make_matrix_1.default)(dSizes, () => {
                count++;
                return generator.values.pop();
            });
            return { count, result };
        }
    }
    static getRandomIndex(max) {
        return Math.floor(Math.random() * max);
    }
    static getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    static getType(type) {
        let constructor = globals_1.Globals.codeUtil.modules[type.file];
        type.namespaces.forEach((namespace) => {
            constructor = constructor[namespace];
        });
        constructor = constructor[type.name];
        return constructor;
    }
    static reset(generator) {
        generator.batchSize = 100;
        generator.values = [];
        generator.count = 0;
    }
}
exports.Generator = Generator;
Generator.mode = Mode_1.Mode.Falsy;
Generator.P_FALSY = 0.85;
Generator.P_STUFF = 0.7;
Generator.DEFAULT_FALSY = [undefined, null];
