"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorInt = void 0;
const limits_1 = require("../utils/limits");
const Generator_1 = require("./Generator");
const Mode_1 = require("./Mode");
class GeneratorInt extends Generator_1.Generator {
    constructor(dimension = 0, literals, min, max, index) {
        super(dimension, new limits_1.Limits({ int: { min, max } }), Generator_1.Generator.getLiterals('integer', literals), index);
        this.falsyLiterals = this.falsyLiterals.concat([
            NaN, 0, -0,
            Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER
        ]);
    }
    generate(count) {
        const result = [];
        if (Generator_1.Generator.mode === Mode_1.Mode.Falsy) {
            for (let index = 0; index < count; index++) {
                result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
            }
        }
        else if (Generator_1.Generator.mode === Mode_1.Mode.Stuff && this.literals.length > 0) {
            for (let index = 0; index < count; index++) {
                if (Math.random() > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
            }
        }
        else {
            const [min, max] = GeneratorInt.getLimits(Generator_1.Generator.mode, this.limits.int.min, this.limits.int.max);
            for (let index = 0; index < count; index++) {
                const random = Math.random();
                if (random > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                else if (random > Generator_1.Generator.P_STUFF && this.literals.length > 0) {
                    result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
                    continue;
                }
                result.push(Generator_1.Generator.getRandomInt(min, max));
            }
        }
        return result;
    }
    next() {
        return Generator_1.Generator.next(this).result;
    }
    static getLimits(mode, min, max) {
        const diff = max - min;
        switch (mode) {
            case Mode_1.Mode.Falsy:
            case Mode_1.Mode.Stuff:
            case Mode_1.Mode.Low_1:
                return [
                    min + diff * GeneratorInt.MODE_SCALE * 1.5,
                    max - diff * GeneratorInt.MODE_SCALE * 1.5
                ];
            case Mode_1.Mode.Low_2:
                return [
                    min + diff * GeneratorInt.MODE_SCALE,
                    max - diff * GeneratorInt.MODE_SCALE
                ];
            case Mode_1.Mode.Medium:
                return [min, max];
            case Mode_1.Mode.High_1:
                return [
                    min - diff * GeneratorInt.MODE_SCALE * 4,
                    max + diff * GeneratorInt.MODE_SCALE * 4
                ];
            case Mode_1.Mode.High_2:
                return [
                    min - diff * GeneratorInt.MODE_SCALE * 40,
                    max + diff * GeneratorInt.MODE_SCALE * 40
                ];
        }
    }
}
exports.GeneratorInt = GeneratorInt;
GeneratorInt.MODE_SCALE = 0.25;
