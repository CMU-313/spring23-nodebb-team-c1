"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorEnum = void 0;
const limits_1 = require("../utils/limits");
const Generator_1 = require("./Generator");
const Mode_1 = require("./Mode");
class GeneratorEnum extends Generator_1.Generator {
    constructor(type, dimension = 0, index) {
        super(dimension, new limits_1.Limits({}), [], index);
        this.falsyLiterals = this.falsyLiterals.concat([
            NaN, 0, -0,
            Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER,
            -1 * Number.MIN_VALUE, Number.MIN_VALUE,
            -1 * Number.MAX_VALUE, Number.MAX_VALUE,
            Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY,
            '', 'RkeRxOSF4BfSpgc5Dc7hGumMO'
        ]);
        this.type = type;
        this.isInit = false;
    }
    generate(count) {
        let result = [];
        this.init();
        switch (Generator_1.Generator.mode) {
            case Mode_1.Mode.Falsy:
                for (let index = 0; index < count; index++) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                }
                break;
            default:
                result = this.renderer.render(count, this.falsyLiterals);
                break;
        }
        return result;
    }
    next() {
        return Generator_1.Generator.next(this).result;
    }
    init() {
        if (this.isInit) {
            return;
        }
        const enumObject = Generator_1.Generator.getType(this.type);
        const numbers = [];
        const strings = [];
        Object.keys(enumObject).forEach((key) => {
            const numericKey = Number.parseInt(key);
            if (Number.isInteger(numericKey)) {
                numbers.push(numericKey);
            }
            else {
                strings.push(key);
            }
        });
        let isInteger;
        const min = numbers[0];
        let max = min;
        if (numbers.length === strings.length) {
            isInteger = true;
            numbers.forEach((key, index) => {
                if (key - min !== index) {
                    isInteger = false;
                }
                max = key;
            });
        }
        else {
            isInteger = false;
        }
        if (isInteger) {
            this.renderer = new IntEnumRender(min, max);
        }
        else {
            const values = strings.map((value) => {
                const numValue = Number.parseFloat(value);
                if (!Number.isNaN(numValue)) {
                    return numValue;
                }
                return enumObject[value];
            });
            this.renderer = new DictionaryEnumRender(values);
        }
        this.isInit = true;
    }
}
exports.GeneratorEnum = GeneratorEnum;
class IntEnumRender {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    render(count, falsyLiterals) {
        const results = [];
        for (let i = 0; i < count; i++) {
            if (Math.random() > Generator_1.Generator.P_FALSY) {
                results.push(falsyLiterals[Generator_1.Generator.getRandomIndex(falsyLiterals.length)]);
                continue;
            }
            results.push(Generator_1.Generator.getRandomInt(this.min, this.max));
        }
        return results;
    }
}
class DictionaryEnumRender {
    constructor(values) {
        this.values = values;
        this.maxIndex = this.values.length;
    }
    render(count, falsyLiterals) {
        const results = [];
        for (let i = 0; i < count; i++) {
            if (Math.random() > Generator_1.Generator.P_FALSY) {
                results.push(falsyLiterals[Generator_1.Generator.getRandomIndex(falsyLiterals.length)]);
                continue;
            }
            results.push(this.values[Generator_1.Generator.getRandomIndex(this.maxIndex)]);
        }
        return results;
    }
}
