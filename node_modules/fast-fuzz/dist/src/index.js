#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const FlatPromise = require('flat-promise');
const commander_1 = __importDefault(require("commander"));
const log_update_1 = __importDefault(require("log-update"));
const fast_safe_stringify_1 = __importDefault(require("fast-safe-stringify"));
const fuzzCaller_1 = require("./fuzz/fuzzCaller");
commander_1.default
    .addHelpCommand()
    .version(require('../../package').version)
    .option('-i, --input <path>', 'Path of the Typescript project.')
    .option('-n, --threads <count>', 'The number of parallel threads. Default = OS defined. 0 for in-process.')
    .option('-t, --maxTime <milliseconds>', 'The maximum time(ms) per function. Actual value is multiplied by 4. Default = 10s.')
    .option('-m, --methods <RegExp>', 'A Regex expression to filter the methods to test.')
    .option('-c, --classes <RegExp>', 'A Regex expression to filter the classes to test.')
    .option('-f, --files <RegExp>', 'A Regex expression to filter the files to test.')
    .option('-s, --source <path>', 'Path of the source folder relative to the project.')
    .option('-d, --dist <path>', 'Path of the binary folder relative to the project.')
    .option('-F, --force true', 'Force overwrite fuzz instances JSON file.')
    .option('-q, --quiet true', 'Only output the results JSON.')
    .parse(process.argv);
if (!commander_1.default.input) {
    console.error('Missing input folder.');
    process.exit(1);
}
function Main() {
    return __awaiter(this, void 0, void 0, function* () {
        if (commander_1.default.threads !== undefined) {
            commander_1.default.threads = Number.parseInt(commander_1.default.threads);
            if (Number.isNaN(commander_1.default.threads)) {
                delete commander_1.default.threads;
            }
        }
        if (commander_1.default.maxTime !== undefined) {
            commander_1.default.maxTime = Number.parseFloat(commander_1.default.maxTime);
            if (Number.isNaN(commander_1.default.maxTime)) {
                delete commander_1.default.maxTime;
            }
        }
        commander_1.default.quiet = commander_1.default.quiet !== undefined;
        commander_1.default.force = commander_1.default.force !== undefined;
        if (!('toJSON' in Error.prototype)) {
            Object.defineProperty(Error.prototype, 'toJSON', {
                value: function () {
                    const alt = {};
                    alt['name'] = this.name;
                    Object.getOwnPropertyNames(this).forEach((key) => {
                        alt[key] = this[key];
                    }, this);
                    return alt;
                },
                configurable: true,
                writable: true
            });
        }
        if (commander_1.default.quiet) {
            console.log((0, fast_safe_stringify_1.default)(yield (0, fuzzCaller_1.fuzz)(commander_1.default.input, commander_1.default.threads, commander_1.default.maxTime, commander_1.default.methods, commander_1.default.classes, commander_1.default.files, commander_1.default.source, commander_1.default.dist, !commander_1.default.quiet, commander_1.default.force)));
            return;
        }
        const start = Date.now();
        const results = [];
        let isResolved = false;
        (0, fuzzCaller_1.fuzz)(commander_1.default.input, commander_1.default.threads, commander_1.default.maxTime, commander_1.default.methods, commander_1.default.classes, commander_1.default.files, commander_1.default.source, commander_1.default.dist, !commander_1.default.quiet, commander_1.default.force, results).then(() => {
            isResolved = true;
        });
        while (!isResolved) {
            yield wait(5000);
            (0, log_update_1.default)((0, fast_safe_stringify_1.default)(results));
        }
        (0, log_update_1.default)((0, fast_safe_stringify_1.default)(results));
        log_update_1.default.done();
        (0, log_update_1.default)(`
    Time elapsed (s): ${(Date.now() - start) / 1e3}
  `);
        log_update_1.default.done();
    });
}
Main();
function wait(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        const flatPromise = new FlatPromise();
        setTimeout(() => flatPromise.resolve(), ms);
        return flatPromise.promise;
    });
}
