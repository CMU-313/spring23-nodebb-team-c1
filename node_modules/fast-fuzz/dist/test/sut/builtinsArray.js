"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Builtins_Array = void 0;
const fast_fuzz_1 = require("../../src/fast-fuzz");
const ints = {
    nil: 0,
    nHard: -525,
    nSoft: -75,
    nMin: -25,
    hard: 525,
    soft: 75,
    max: 25,
};
const floats = {
    nil: 0,
    nHard: -210,
    nSoft: -30,
    nMin: -10,
    hard: 210,
    soft: 30,
    max: 10,
};
const dates = {
    nil: 0,
    now: Date.now(),
    y2K: 946677600000,
    nHard: Date.now() - 8.64e+7 * 2 * 10,
    nSoft: Date.now() - 8.64e+7 * 2,
    nMin: Date.now() - 8.64e+7,
    hard: Date.now() + 8.64e+7 * 2 * 10,
    soft: Date.now() + 8.64e+7 * 2,
    max: Date.now() + 8.64e+7,
    dateMin: -8640e12,
    dateMax: 8640e12
};
const strings = {
    nil: 0,
    hard: 6,
    soft: 5,
    max: 4,
    long: 25
};
class Builtins_Array {
    static builtin_bool_array(argArray) {
        switch (argArray) {
            case undefined:
                return `Undefined []: ${argArray}`;
            case null:
                return `Null []: ${argArray}`;
            default:
                break;
        }
        if (argArray.length === 0) {
            return `Empty []: ${JSON.stringify(argArray)}`;
        }
        const arg = argArray[0];
        switch (arg) {
            case undefined:
                return `Undefined: ${arg}`;
            case null:
                return `Null: ${arg}`;
            case false:
                return `False: ${arg}`;
            case true:
                return `True: ${arg}`;
            default:
                return `Unkown: ${arg}`;
        }
    }
    static builtin_int_array(argArray) {
        switch (argArray) {
            case undefined:
                return `Undefined []: ${argArray}`;
            case null:
                return `Null []: ${argArray}`;
            default:
                break;
        }
        if (argArray.length === 0) {
            return `Empty []: ${JSON.stringify(argArray)}`;
        }
        const arg = argArray[0];
        if (arg === undefined) {
            return `Undefined: ${arg}`;
        }
        else if (arg === null) {
            return `Null: ${arg}`;
        }
        else if (Number.isNaN(arg)) {
            return `NaN: ${arg}`;
        }
        else if (arg === ints.nil) {
            return `Zero: ${arg}`;
        }
        else if (arg === Number.MIN_SAFE_INTEGER) {
            return `Min int: ${arg}`;
        }
        else if (arg === Number.MAX_SAFE_INTEGER) {
            return `Max int: ${arg}`;
        }
        else if (arg < ints.nHard) {
            return `Min hard limit: ${arg}`;
        }
        else if (arg < ints.nSoft) {
            return `Min soft limit: ${arg}`;
        }
        else if (arg < ints.nMin) {
            return `Min limit: ${arg}`;
        }
        else if (arg < ints.nil) {
            return `Negative: ${arg}`;
        }
        else if (arg > ints.hard) {
            return `Max hard limit: ${arg}`;
        }
        else if (arg > ints.soft) {
            return `Max soft limit: ${arg}`;
        }
        else if (arg > ints.max) {
            return `Max limit: ${arg}`;
        }
        else if (arg > ints.nil) {
            return `Positive: ${arg}`;
        }
        else {
            return `Unkown: ${arg}`;
        }
    }
    static builtin_float_array(argArray) {
        switch (argArray) {
            case undefined:
                return `Undefined []: ${argArray}`;
            case null:
                return `Null []: ${argArray}`;
            default:
                break;
        }
        if (argArray.length === 0) {
            return `Empty []: ${JSON.stringify(argArray)}`;
        }
        const arg = argArray[0];
        if (arg === undefined) {
            return `Undefined: ${arg}`;
        }
        else if (arg === null) {
            return `Null: ${arg}`;
        }
        else if (Number.isNaN(arg)) {
            return `NaN: ${arg}`;
        }
        else if (arg === floats.nil) {
            return `Zero: ${arg}`;
        }
        else if (arg === -1 * Number.MIN_VALUE) {
            return `Negative min decimal: ${arg}`;
        }
        else if (arg === Number.MIN_VALUE) {
            return `Positive min decimal: ${arg}`;
        }
        else if (arg === -1 * Number.MAX_VALUE) {
            return `Min float: ${arg}`;
        }
        else if (arg === Number.MAX_VALUE) {
            return `Max float: ${arg}`;
        }
        else if (arg === Number.NEGATIVE_INFINITY) {
            return `Negative infinity: ${arg}`;
        }
        else if (arg === Number.POSITIVE_INFINITY) {
            return `Positive infinity: ${arg}`;
        }
        else if (arg < floats.nHard) {
            return `Min hard limit: ${arg}`;
        }
        else if (arg < floats.nSoft) {
            return `Min soft limit: ${arg}`;
        }
        else if (arg < floats.nMin) {
            return `Min limit: ${arg}`;
        }
        else if (arg < floats.nil) {
            return `Negative: ${arg}`;
        }
        else if (arg > floats.hard) {
            return `Max hard limit: ${arg}`;
        }
        else if (arg > floats.soft) {
            return `Max soft limit: ${arg}`;
        }
        else if (arg > floats.max) {
            return `Max limit: ${arg}`;
        }
        else if (arg > floats.nil) {
            return `Positive: ${arg}`;
        }
        else {
            return `Unkown: ${arg}`;
        }
    }
    static builtin_date_array(argArray) {
        switch (argArray) {
            case undefined:
                return `Undefined []: ${argArray}`;
            case null:
                return `Null []: ${argArray}`;
            default:
                break;
        }
        if (argArray.length === 0) {
            return `Empty []: ${JSON.stringify(argArray)}`;
        }
        const arg1 = argArray[0];
        const arg = arg1 === null || arg1 === void 0 ? void 0 : arg1.getTime();
        if (arg1 === undefined) {
            return `Undefined: ${arg1}`;
        }
        else if (arg1 === null) {
            return `Null: ${arg1}`;
        }
        else if (Number.isNaN(arg)) {
            return `NaN: ${arg}`;
        }
        else if (arg === dates.nil) {
            return `Zero: ${arg}`;
        }
        else if (arg === dates.y2K) {
            return `Y2K: ${arg}`;
        }
        else if (arg === dates.dateMin) {
            return `Min date: ${arg}`;
        }
        else if (arg === dates.dateMax) {
            return `Max date: ${arg}`;
        }
        else if (arg < dates.nHard) {
            return `Min hard limit: ${arg}`;
        }
        else if (arg < dates.nSoft) {
            return `Min soft limit: ${arg}`;
        }
        else if (arg < dates.nMin) {
            return `Min limit: ${arg}`;
        }
        else if (arg < dates.now) {
            return `Negative: ${arg}`;
        }
        else if (arg > dates.hard) {
            return `Max hard limit: ${arg}`;
        }
        else if (arg > dates.soft) {
            return `Max soft limit: ${arg}`;
        }
        else if (arg > dates.max) {
            return `Max limit: ${arg}`;
        }
        else if (arg > dates.now) {
            return `Positive: ${arg}`;
        }
        else {
            return `Unkown: ${arg}`;
        }
    }
    static builtin_string_array(argArray) {
        switch (argArray) {
            case undefined:
                return `Undefined []: ${argArray}`;
            case null:
                return `Null []: ${argArray}`;
            default:
                break;
        }
        if (argArray.length === 0) {
            return `Empty []: ${JSON.stringify(argArray)}`;
        }
        const arg = argArray[0];
        const len = arg === null || arg === void 0 ? void 0 : arg.length;
        if (arg === undefined) {
            return `Undefined: ${arg}`;
        }
        else if (arg === null) {
            return `Null: ${arg}`;
        }
        else if (len === strings.nil) {
            return `Zero: ${arg}`;
        }
        else if (len === strings.long) {
            return `Long literal(25): ${arg}`;
        }
        else if (len > strings.hard) {
            return `Max hard limit: ${arg}`;
        }
        else if (len > strings.soft) {
            return `Max soft limit: ${arg}`;
        }
        else if (len > strings.max) {
            return `Max limit: ${arg}`;
        }
        else if (len > strings.nil) {
            return `Positive: ${arg}`;
        }
        else {
            return `Unkown: ${arg}`;
        }
    }
}
__decorate([
    fast_fuzz_1.fuzzMethod,
    __param(0, (0, fast_fuzz_1.fuzzArg)('boolean', 1)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", String)
], Builtins_Array, "builtin_bool_array", null);
__decorate([
    fast_fuzz_1.fuzzMethod,
    __param(0, (0, fast_fuzz_1.fuzzArg)('integer', 1)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", String)
], Builtins_Array, "builtin_int_array", null);
__decorate([
    fast_fuzz_1.fuzzMethod,
    __param(0, (0, fast_fuzz_1.fuzzArg)('float', 1)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", String)
], Builtins_Array, "builtin_float_array", null);
__decorate([
    fast_fuzz_1.fuzzMethod,
    __param(0, (0, fast_fuzz_1.fuzzArg)('date', 1)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", String)
], Builtins_Array, "builtin_date_array", null);
__decorate([
    fast_fuzz_1.fuzzMethod,
    __param(0, (0, fast_fuzz_1.fuzzArg)('string', 1)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", String)
], Builtins_Array, "builtin_string_array", null);
exports.Builtins_Array = Builtins_Array;
