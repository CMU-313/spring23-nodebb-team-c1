"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decorators = exports.MethodArg = void 0;
const GeneratorFactory_1 = require("../generators/GeneratorFactory");
const GeneratorFalsy_1 = require("../generators/GeneratorFalsy");
const globals_1 = require("./globals");
class MethodArg {
}
exports.MethodArg = MethodArg;
class Decorators {
    static addArgument(target, key, arg) {
        if (!Decorators.checkMethod(5, target, key, arg.index)) {
            Decorators.resetMethod();
        }
        if (Decorators.args.length === 0) {
            Decorators.fileName = Decorators.getFileName(4);
            Decorators.className = Decorators.getMethodName(target);
            Decorators.methodName = new String(key).toString();
            Decorators.lastIndex = arg.index;
        }
        Decorators.args.push(arg);
    }
    static addMethod(target, key, file, method) {
        if (!Decorators.checkMethod(8, target, key, -1)) {
            Decorators.resetMethod();
        }
        const generators = Decorators.addMethodArgs(this.args, file, method);
        const result = {
            args: this.args,
            isStart: false,
            generators: generators.generators,
            typeGenerators: generators.typeGenerators
        };
        method.test = result;
        Decorators.resetMethod();
        return result;
    }
    static addMethodArgs(args, file, method) {
        const result = {
            generators: [],
            typeGenerators: []
        };
        args.forEach((arg) => {
            if (arg.isSkip) {
                result.generators.push(new GeneratorFalsy_1.GeneratorFalsy(0, arg.index));
                return;
            }
            let isBuiltIn = false;
            switch (arg.type) {
                case 'boolean':
                case 'integer':
                case 'float':
                case 'date':
                case 'string':
                    isBuiltIn = true;
                    break;
                default:
                    break;
            }
            let type;
            if (!isBuiltIn) {
                type = globals_1.Globals.codeUtil.types[file]
                    .find((localType) => localType.name === arg.type);
                if (type === undefined) {
                    type = globals_1.Globals.codeUtil.findType(arg.type, method.IArgs, file);
                }
                if (type === undefined) {
                    console.warn(`
              Missing type on decorated method:
              File name: ${file},
              Class name: ${method.className},
              Method name: ${method.name},
              Argument: ${JSON.stringify(arg)}
            `);
                    return;
                }
            }
            if (isBuiltIn) {
                result.generators.push(GeneratorFactory_1.GeneratorFactory.init(arg.type, arg.dimension, method.literals, arg.index, arg.min, arg.max));
            }
            else {
                const typeGenerator = GeneratorFactory_1.GeneratorFactory.initType(type, arg.dimension, arg.index);
                result.generators.push(typeGenerator);
                if (type.kind === 'enum') {
                    return;
                }
                result.typeGenerators.push(typeGenerator);
            }
        });
        return result;
    }
    static skipMethod(target, key) {
        Decorators.resetMethod();
        const newFileName = Decorators.getFileName(7);
        const newClassName = Decorators.getMethodName(target);
        const newMethodName = new String(key).toString();
        const index = globals_1.Globals
            .codeUtil
            .methods[newFileName]
            .findIndex((method) => method.name === newMethodName &&
            method.className === newClassName);
        globals_1.Globals
            .codeUtil
            .methods[newFileName]
            .splice(index, 1);
    }
    static getPropType(typeName) {
        const fileName = Decorators.getFileName(7);
        let type;
        type = globals_1.Globals.codeUtil.types[fileName]
            .find((localType) => localType.name === typeName);
        if (type === undefined) {
            type = globals_1.Globals.codeUtil.findType(typeName, globals_1.Globals.codeUtil.interfaces[fileName], fileName);
        }
        return type;
    }
    static getFileName(index) {
        const stackLines = ((new Error()).stack).split('\n');
        let file = stackLines[index];
        file = file.replace(new RegExp('^[\\s]*at '), '');
        const fileBrackets = file.match(new RegExp('\\(\\S*\\)'));
        if ((fileBrackets === null || fileBrackets === void 0 ? void 0 : fileBrackets.length) > 0) {
            file = fileBrackets[0].substring(1, fileBrackets[0].length - 1);
        }
        file = file.replace(new RegExp(':[0-9]*:[0-9]*$'), '');
        return file;
    }
    static getMethodName(target) {
        if (target.constructor.name === 'Function') {
            return target.name;
        }
        return target.constructor.name;
    }
    static checkMethod(stackIndex, target, key, index) {
        const newFileName = Decorators.getFileName(stackIndex);
        const newClassName = Decorators.getMethodName(target);
        const newMethodName = new String(key).toString();
        if (Decorators.args.length > 0 &&
            !(newFileName === Decorators.fileName &&
                newClassName === Decorators.className &&
                newMethodName === Decorators.methodName &&
                (Decorators.lastIndex > index))) {
            console.warn(`
          Missing method decorator:
          File name: ${Decorators.fileName},
          Class name: ${Decorators.className},
          Method name: ${Decorators.methodName},
          Arguments: ${JSON.stringify(Decorators.args)}
        `);
            return false;
        }
        return true;
    }
    static resetMethod() {
        Decorators.fileName = undefined;
        Decorators.className = undefined;
        Decorators.methodName = undefined;
        Decorators.lastIndex = undefined;
        Decorators.args = [];
    }
}
exports.Decorators = Decorators;
Decorators.args = [];
