"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorDate = void 0;
const limits_1 = require("../utils/limits");
const Generator_1 = require("./Generator");
const Mode_1 = require("./Mode");
class GeneratorDate extends Generator_1.Generator {
    constructor(dimension = 0, literals, min, max, index) {
        super(dimension, new limits_1.Limits({ date: { min, max } }), Generator_1.Generator.getLiterals('date', literals), index);
        this.falsyLiterals = this.falsyLiterals.concat([
            new Date(0),
            new Date(Date.parse('0')),
            new Date(-8640e12),
            new Date(8640e12)
        ]);
    }
    generate(count) {
        const result = [];
        if (Generator_1.Generator.mode === Mode_1.Mode.Falsy) {
            for (let index = 0; index < count; index++) {
                result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
            }
        }
        else if (Generator_1.Generator.mode === Mode_1.Mode.Stuff && this.literals.length > 0) {
            for (let index = 0; index < count; index++) {
                if (Math.random() > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
            }
        }
        else {
            const [min, max] = GeneratorDate.getLimits(Generator_1.Generator.mode, this.limits.date.min, this.limits.date.max);
            for (let index = 0; index < count; index++) {
                const random = Math.random();
                if (random > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                else if (random > Generator_1.Generator.P_STUFF && this.literals.length > 0) {
                    result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
                    continue;
                }
                result.push(new Date(Generator_1.Generator.getRandomInt(min, max)));
            }
        }
        return result;
    }
    next() {
        return Generator_1.Generator.next(this).result;
    }
    static getLimits(mode, min, max) {
        const diff = max - min;
        switch (mode) {
            case Mode_1.Mode.Falsy:
            case Mode_1.Mode.Stuff:
            case Mode_1.Mode.Low_1:
                return [
                    min + diff * GeneratorDate.MODE_SCALE * 1.5,
                    max - diff * GeneratorDate.MODE_SCALE * 1.5
                ];
            case Mode_1.Mode.Low_2:
                return [
                    min + diff * GeneratorDate.MODE_SCALE,
                    max - diff * GeneratorDate.MODE_SCALE
                ];
            case Mode_1.Mode.Medium:
                return [min, max];
            case Mode_1.Mode.High_1:
                return [
                    min - diff * GeneratorDate.MODE_SCALE * 4,
                    max + diff * GeneratorDate.MODE_SCALE * 4
                ];
            case Mode_1.Mode.High_2:
                return [
                    min - diff * GeneratorDate.MODE_SCALE * 40,
                    max + diff * GeneratorDate.MODE_SCALE * 40
                ];
        }
    }
}
exports.GeneratorDate = GeneratorDate;
GeneratorDate.MODE_SCALE = 0.25;
