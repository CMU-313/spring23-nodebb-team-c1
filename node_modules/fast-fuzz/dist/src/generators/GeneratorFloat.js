"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorFloat = void 0;
const limits_1 = require("../utils/limits");
const Generator_1 = require("./Generator");
const Mode_1 = require("./Mode");
class GeneratorFloat extends Generator_1.Generator {
    constructor(dimension = 0, literals, min, max, index) {
        super(dimension, new limits_1.Limits({ float: { min, max } }), Generator_1.Generator.getLiterals('float', literals), index);
        this.falsyLiterals = this.falsyLiterals.concat([
            NaN, 0, -0,
            -1 * Number.MIN_VALUE, Number.MIN_VALUE,
            -1 * Number.MAX_VALUE, Number.MAX_VALUE,
            Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY
        ]);
    }
    generate(count) {
        const result = [];
        if (Generator_1.Generator.mode === Mode_1.Mode.Falsy) {
            for (let index = 0; index < count; index++) {
                result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
            }
        }
        else if (Generator_1.Generator.mode === Mode_1.Mode.Stuff && this.literals.length > 0) {
            for (let index = 0; index < count; index++) {
                if (Math.random() > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
            }
        }
        else {
            const [min, max] = GeneratorFloat.getLimits(Generator_1.Generator.mode, this.limits.float.min, this.limits.float.max);
            for (let index = 0; index < count; index++) {
                const random = Math.random();
                if (random > Generator_1.Generator.P_FALSY) {
                    result.push(this.falsyLiterals[Generator_1.Generator.getRandomIndex(this.falsyLiterals.length)]);
                    continue;
                }
                else if (random > Generator_1.Generator.P_STUFF && this.literals.length > 0) {
                    result.push(this.literals[Generator_1.Generator.getRandomIndex(this.literals.length)]);
                    continue;
                }
                result.push(GeneratorFloat.getRandomFloat(min, max));
            }
        }
        return result;
    }
    next() {
        return Generator_1.Generator.next(this).result;
    }
    static getRandomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }
    static getLimits(mode, min, max) {
        const diff = max - min;
        switch (mode) {
            case Mode_1.Mode.Falsy:
            case Mode_1.Mode.Stuff:
            case Mode_1.Mode.Low_1:
                return [
                    min + diff * GeneratorFloat.MODE_SCALE * 1.5,
                    max - diff * GeneratorFloat.MODE_SCALE * 1.5
                ];
            case Mode_1.Mode.Low_2:
                return [
                    min + diff * GeneratorFloat.MODE_SCALE,
                    max - diff * GeneratorFloat.MODE_SCALE
                ];
            case Mode_1.Mode.Medium:
                return [min, max];
            case Mode_1.Mode.High_1:
                return [
                    min - diff * GeneratorFloat.MODE_SCALE * 4,
                    max + diff * GeneratorFloat.MODE_SCALE * 4
                ];
            case Mode_1.Mode.High_2:
                return [
                    min - diff * GeneratorFloat.MODE_SCALE * 40,
                    max + diff * GeneratorFloat.MODE_SCALE * 40
                ];
        }
    }
}
exports.GeneratorFloat = GeneratorFloat;
GeneratorFloat.MODE_SCALE = 0.25;
