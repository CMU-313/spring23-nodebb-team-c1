"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.skipMethod = exports.method = exports.skipArg = exports.argType = exports.arg = exports.skipProp = exports.propType = exports.prop = void 0;
const class_transformer_1 = require("class-transformer");
const Generator_1 = require("./generators/Generator");
const GeneratorFactory_1 = require("./generators/GeneratorFactory");
const Mode_1 = require("./generators/Mode");
const decorators_1 = require("./utils/decorators");
const globals_1 = require("./utils/globals");
const prop = function (type, dimension = 0, min, max) {
    return (target, key) => {
        if (!globals_1.Globals.isTest) {
            return;
        }
        let methodId = 0;
        let methodMode = Mode_1.Mode.Falsy;
        let generator;
        (0, class_transformer_1.Transform)(({ value }) => {
            if (globals_1.Globals.isLoading) {
                return value;
            }
            if (methodId !== globals_1.Globals.methodCount ||
                methodMode !== globals_1.Globals.mode) {
                generator = GeneratorFactory_1.GeneratorFactory.init(type, dimension, globals_1.Globals.literals, undefined, min, max);
                methodId = globals_1.Globals.methodCount;
                methodMode = globals_1.Globals.mode;
            }
            return generator.next();
        })(target, key);
    };
};
exports.prop = prop;
const propType = function (typeName, dimension = 0) {
    return (target, key) => {
        if (!globals_1.Globals.isTest) {
            return;
        }
        const type = decorators_1.Decorators.getPropType(typeName);
        if (type === undefined) {
            console.warn(`
          Missing type on decorated property:
          File name: ${decorators_1.Decorators.getFileName(6)},
          Class name: ${decorators_1.Decorators.getMethodName(target)},
          Property name: ${new String(key).toString()},
          Argument: ${JSON.stringify(exports.arg)}
        `);
            return;
        }
        let methodId = 0;
        let methodMode = Mode_1.Mode.Falsy;
        let generator;
        (0, class_transformer_1.Transform)(() => {
            if (methodId !== globals_1.Globals.methodCount ||
                methodMode !== globals_1.Globals.mode) {
                generator = GeneratorFactory_1.GeneratorFactory.initType(type, dimension);
                methodId = globals_1.Globals.methodCount;
                methodMode = globals_1.Globals.mode;
            }
            return generator.next();
        })(target, key);
    };
};
exports.propType = propType;
const skipProp = (target, key) => {
    if (!globals_1.Globals.isTest) {
        return;
    }
    (0, class_transformer_1.Exclude)()(target, key);
};
exports.skipProp = skipProp;
const arg = function (type, dimension = 0, min, max) {
    return (target, key, index) => {
        if (!globals_1.Globals.isTest) {
            return;
        }
        decorators_1.Decorators.addArgument(target, key, { index, type, dimension, min, max, isSkip: false });
    };
};
exports.arg = arg;
const argType = function (type, dimension = 0) {
    return (target, key, index) => {
        if (!globals_1.Globals.isTest) {
            return;
        }
        decorators_1.Decorators.addArgument(target, key, { index, type, dimension, isSkip: false });
    };
};
exports.argType = argType;
const skipArg = (target, key, index) => {
    if (!globals_1.Globals.isTest) {
        return;
    }
    decorators_1.Decorators.addArgument(target, key, { index, dimension: 0, type: '', isSkip: true });
};
exports.skipArg = skipArg;
const method = (target, key, descriptor) => {
    if (!globals_1.Globals.isTest) {
        return descriptor;
    }
    const fileName = decorators_1.Decorators.getFileName(6);
    const className = decorators_1.Decorators.getMethodName(target);
    const methodName = new String(key).toString();
    const method = globals_1.Globals
        .codeUtil
        .methods[fileName]
        .find((method) => method.name === methodName &&
        method.className === className);
    const testArgs = decorators_1.Decorators.addMethod(target, key, fileName, method);
    const originalMethod = descriptor.value;
    const methodId = 0;
    const methodMode = Mode_1.Mode.Falsy;
    descriptor.value = function (...args) {
        if (!testArgs.isStart) {
            return originalMethod.apply(this, args);
        }
        if (methodId !== globals_1.Globals.methodCount ||
            methodMode !== globals_1.Globals.mode) {
            const generators = decorators_1.Decorators.addMethodArgs(testArgs.args, fileName, method);
            testArgs.generators = generators.generators;
            testArgs.typeGenerators = generators.typeGenerators;
        }
        testArgs.generators.forEach((generator) => {
            args[generator.index] = generator.next();
        });
        if (Generator_1.Generator.mode !== Mode_1.Mode.Falsy) {
            testArgs.typeGenerators.forEach((generator) => {
                testArgs.callArgsTypes.push(generator.nextTypes());
            });
        }
        testArgs.isStart = false;
        testArgs.callArgs = args;
        return originalMethod.apply(this, args);
    };
    return descriptor;
};
exports.method = method;
const skipMethod = (target, key, descriptor) => {
    if (!globals_1.Globals.isTest) {
        return descriptor;
    }
    decorators_1.Decorators.skipMethod(target, key);
    return descriptor;
};
exports.skipMethod = skipMethod;
